import ast
import symtable
from collections import defaultdict
import pandas as pd
import os
import re
import textwrap
from anytree import Node, RenderTree
from anytree.exporter import DotExporter

class FunctionAnalyzer:
    def __init__(self, code_string=None, file_path=None):
        """Initialize with either code string or file path"""
        if file_path and os.path.exists(file_path):
            with open(file_path, 'r') as f:
                self.code_string = f.read()
            self.source_name = os.path.basename(file_path)
        elif code_string:
            self.code_string = code_string
            self.source_name = "<string>"
        else:
            raise ValueError("Either code_string or valid file_path must be provided")
            
        # Parse the code
        self.parsed = ast.parse(self.code_string)
        self.functions = {}
        self.class_functions = defaultdict(list)
        self.module_vars = set()
        self.trees = {}
        
    def analyze(self):
        """Analyze code to find undefined variables and other metrics"""
        # Extract module-level variables
        for node in ast.walk(self.parsed):
            if isinstance(node, ast.Assign):
                for target in node.targets:
                    if isinstance(target, ast.Name):
                        self.module_vars.add(target.id)
        
        # Analyze each function
        for node in ast.walk(self.parsed):
            if isinstance(node, ast.FunctionDef):
                function_info = self._analyze_function(node)
                self.functions[node.name] = function_info
                
                # Build function tree
                self.trees[node.name] = self._build_function_tree(node)
            
            # Track class methods
            elif isinstance(node, ast.ClassDef):
                class_name = node.name
                for item in node.body:
                    if isinstance(item, ast.FunctionDef):
                        self.class_functions[class_name].append(item.name)
        
        return self.functions
    
    def _analyze_function(self, node):
        """Analyze a specific function node"""
        # Create function info dictionary
        info = {
            'name': node.name,
            'args': [arg.arg for arg in node.args.args],
            'defaults': len(node.args.defaults),
            'kwonly_args': [arg.arg for arg in node.args.kwonlyargs] if hasattr(node.args, 'kwonlyargs') else [],
            'vararg': node.args.vararg.arg if node.args.vararg else None,
            'kwarg': node.args.kwarg.arg if node.args.kwarg else None,
            'docstring': ast.get_docstring(node),
            'line_start': node.lineno,
            'line_end': node.end_lineno if hasattr(node, 'end_lineno') else node.lineno,
            'decorators': [d.id if isinstance(d, ast.Name) else None for d in node.decorator_list],
            'returns': None,
            'complexity': 0,
            'variables': {
                'local': set(),
                'referenced': set(),
                'undefined': set()
            }
        }
        
        # Extract return annotation if exists
        if node.returns:
            if isinstance(node.returns, ast.Name):
                info['returns'] = node.returns.id
            elif isinstance(node.returns, ast.Constant):
                info['returns'] = str(node.returns.value)
        
        # Calculate complexity (approximation of cyclomatic complexity)
        info['complexity'] = self._calculate_complexity(node)
        
        # Get variables information using symbol table
        try:
            subtree = ast.Module(body=[node], type_ignores=[])
            table = symtable.symtable(ast.unparse(subtree), self.source_name, "exec")
            function_table = table.get_children()[0]  # Get the function's symbol table
            
            for name in function_table.get_identifiers():
                symbol = function_table.lookup(name)
                
                if symbol.is_local():
                    info['variables']['local'].add(name)
                    
                if symbol.is_referenced():
                    info['variables']['referenced'].add(name)
                    
                    # Check if it's undefined (not parameter, not local, not imported, not global)
                    if not (symbol.is_parameter() or 
                            symbol.is_local() or 
                            symbol.is_imported() or 
                            symbol.is_global() or
                            name in self.module_vars or
                            name in dir(__builtins__)):
                        info['variables']['undefined'].add(name)
        except Exception as e:
            info['errors'] = str(e)
            
        return info
    
    def _calculate_complexity(self, node):
        """Calculate approximate cyclomatic complexity"""
        complexity = 1  # Base complexity
        
        # Count branching statements
        for subnode in ast.walk(node):
            if isinstance(subnode, (ast.If, ast.For, ast.While, ast.Try, ast.ExceptHandler)):
                complexity += 1
            elif isinstance(subnode, ast.BoolOp) and isinstance(subnode.op, ast.And):
                complexity += len(subnode.values) - 1
            elif isinstance(subnode, ast.BoolOp) and isinstance(subnode.op, ast.Or):
                complexity += len(subnode.values) - 1
                
        return complexity
    
    def _build_function_tree(self, node, parent=None):
        """Build a tree representation of the function's AST"""
        if parent is None:
            root = Node(f"Function: {node.name}")
            parent = root
        
        # Add args node
        args_node = Node(f"Args: {', '.join([arg.arg for arg in node.args.args])}", parent=parent)
        
        # Walk body and create tree
        for item in node.body:
            if isinstance(item, ast.Assign):
                targets = []
                for target in item.targets:
                    if isinstance(target, ast.Name):
                        targets.append(target.id)
                    elif isinstance(target, ast.Attribute):
                        targets.append(f"{target.value.id}.{target.attr}" if hasattr(target.value, 'id') else "attr")
                target_str = ', '.join(targets)
                Node(f"Assign: {target_str}", parent=parent)
            
            elif isinstance(item, ast.Expr):
                if isinstance(item.value, ast.Call):
                    if hasattr(item.value.func, 'id'):
                        Node(f"Call: {item.value.func.id}()", parent=parent)
                    elif hasattr(item.value.func, 'attr'):
                        Node(f"Call: {item.value.func.attr}()", parent=parent)
            
            elif isinstance(item, ast.Return):
                Node("Return", parent=parent)
                
            elif isinstance(item, ast.If):
                if_node = Node("If", parent=parent)
                for subitem in item.body:
                    self._build_function_tree_node(subitem, if_node)
                if item.orelse:
                    else_node = Node("Else", parent=parent)
                    for subitem in item.orelse:
                        self._build_function_tree_node(subitem, else_node)
            
            elif isinstance(item, ast.For):
                for_node = Node(f"For: {item.target.id if hasattr(item.target, 'id') else 'loop'}", parent=parent)
                for subitem in item.body:
                    self._build_function_tree_node(subitem, for_node)
            
            elif isinstance(item, ast.While):
                while_node = Node("While", parent=parent)
                for subitem in item.body:
                    self._build_function_tree_node(subitem, while_node)
        
        return root
    
    def _build_function_tree_node(self, node, parent):
        """Helper method to build tree nodes for function body items"""
        if isinstance(node, ast.Assign):
            targets = []
            for target in node.targets:
                if isinstance(target, ast.Name):
                    targets.append(target.id)
            target_str = ', '.join(targets)
            Node(f"Assign: {target_str}", parent=parent)
        
        elif isinstance(node, ast.Expr):
            if isinstance(node.value, ast.Call):
                if hasattr(node.value.func, 'id'):
                    Node(f"Call: {node.value.func.id}()", parent=parent)
                elif hasattr(node.value.func, 'attr'):
                    Node(f"Call: {node.value.func.attr}()", parent=parent)
        
        elif isinstance(node, ast.Return):
            Node("Return", parent=parent)
    
    def export_to_excel(self, output_path):
        """Export analysis results to Excel"""
        # Create function data for DataFrame
        function_data = []
        for func_name, info in self.functions.items():
            function_data.append({
                'Function': func_name,
                'Arguments': ', '.join(info['args']),
                'Line Start': info['line_start'],
                'Line End': info['line_end'],
                'Complexity': info['complexity'],
                'Local Variables': ', '.join(info['variables']['local']),
                'Undefined Variables': ', '.join(info['variables']['undefined']),
                'Is Class Method': any(func_name in methods for _, methods in self.class_functions.items()),
                'Docstring': textwrap.shorten(info['docstring'] or "", width=50)
            })
        
        # Create Excel writer
        with pd.ExcelWriter(output_path, engine='xlsxwriter') as writer:
            # Function overview sheet
            df_functions = pd.DataFrame(function_data)
            df_functions.to_excel(writer, sheet_name='Functions', index=False)
            
            # Format the sheet
            workbook = writer.book
            worksheet = writer.sheets['Functions']
            
            # Add formats
            header_format = workbook.add_format({'bold': True, 'bg_color': '#D9E1F2', 'border': 1})
            warning_format = workbook.add_format({'bg_color': '#FFC7CE'})
            
            # Apply header format
            for col_num, value in enumerate(df_functions.columns.values):
                worksheet.write(0, col_num, value, header_format)
            
            # Highlight rows with undefined variables
            for i, row in df_functions.iterrows():
                if row['Undefined Variables']:
                    worksheet.set_row(i + 1, None, warning_format)
            
            # Variable details sheet
            var_data = []
            for func_name, info in self.functions.items():
                for var in info['variables']['referenced']:
                    var_type = 'Parameter' if var in info['args'] else \
                              'Local' if var in info['variables']['local'] else \
                              'Undefined' if var in info['variables']['undefined'] else \
                              'Global/Imported'
                    var_data.append({
                        'Function': func_name,
                        'Variable': var,
                        'Type': var_type
                    })
            
            df_vars = pd.DataFrame(var_data)
            df_vars.to_excel(writer, sheet_name='Variables', index=False)
            
            # Format variables sheet
            var_worksheet = writer.sheets['Variables']
            for col_num, value in enumerate(df_vars.columns.values):
                var_worksheet.write(0, col_num, value, header_format)
        
        return output_path
    
    def visualize_function(self, function_name, output_path=None):
        """Visualize function as a tree and optionally save to file"""
        if function_name not in self.trees:
            return f"Function '{function_name}' not found"
        
        # Print tree to console
        tree_str = ""
        for pre, _, node in RenderTree(self.trees[function_name]):
            tree_str += f"{pre}{node.name}\n"
        
        # Export to dot file if output path provided
        if output_path:
            DotExporter(self.trees[function_name]).to_dotfile(output_path)
            return f"Tree exported to {output_path}"
        
        return tree_str

# Example usage
if __name__ == "__main__":
    code = """
    def process_data(df, column_name):
        result = df[column_name].sum()
        if result > 0:
            processed = result * 2
            return processed
        else:
            return result * multiplier  # multiplier is undefined

    def valid_function(a, b):
        c = a + b
        for i in range(10):
            c += i
        return c
    """
    
    # Analyze the code
    analyzer = FunctionAnalyzer(code_string=code)
    functions = analyzer.analyze()
    
    # Print results
    for func_name, info in functions.items():
        print(f"Function: {func_name}")
        print(f"Arguments: {info['args']}")
        print(f"Complexity: {info['complexity']}")
        print(f"Undefined variables: {info['variables']['undefined']}")
        print(f"Tree structure:")
        print(analyzer.visualize_function(func_name))
        print("-" * 50)
    
    # Export to Excel
    excel_path = "function_analysis.xlsx"
    analyzer.export_to_excel(excel_path)
    print(f"Analysis exported to {excel_path}")
